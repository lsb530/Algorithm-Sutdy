선택 정렬을 응용한 알고리즘인 힙 정렬
힙은 '부모의 값이 자식의 값보다 항상 크다'는 조건을 만족하는 완전 이진트리이다.
이때 부모의 값이 자식의 값보다 항상 작아도 힙이라고 한다. 즉, 이러한 두 값의 대소관계가 일정하면 된다.

    [ 완전이진트리 ]                      [ 힙 ]
           4                                9  (힙의 루트는 최대값)
         /  \          힙으로만들기        /  \
        6    8           ======>         7     8       *모든 부모와 자식 관계는 항상
       / \  /                           / \   /         (부모의 값 >= 자식)의 값이 성립해야 함
      7   5 9                          6  5  4

힙에서 부모와 잣기 관계는 일정하지만 형제 사이의 대소 관계는 일정하지 않다.
예를 들어 오른쪽 힙에서 형제인 7, 8에서는 작은 쪽인 7이 왼쪽에 있지만, 6과 5에서는 작은쪽인 5가 오른쪽에 있다.
따라서 힙은 형제의 대소 관계가 정해져 있지 않으므로 부분 순서 트리(Partial Ordered Tree)라고도 한다.

* 힙의 원소를 배열에 어떻게 저장할 것인가?
              (0)
              10                루트(최대값)
            /   \               0    1   2   3   4   5   6   7   8   9
           9     5           a[ 10   9   5   8   3   2   4   6   7   1 ]
          / \   / \
         8   3 2   4
        / \ /
       6  7 1
힙의 원소를 배열에 어떻게 저장할 것인지를 나타낸다. 먼저 가장 위쪽에 있는 루트(10)를 a[0]에 저장한다.
그리고 한 단계 아래에서 왼쪽 원소(9)에서 오른쪽 원소(5)로 따라간다. 이 과정에서 배열의 인덱스값을 1씩 증가시키면서
각 원소를 저장한다. 이 작업을 가장 마지막에 있는 원소(1)까지 반복하여 힙을 배열에 저장하면 완료된다. ( 너비탐색느낌 )
이러한 순서로 힙을 배열에 저장하면 부모 인덱스와 왼쪽 자식, 오른쪽 자식 인덱스 사이에는 다음과 같은 관계가 성립한다.
 * 원소 a[i]에서
- 부모: a[(i - 1) // 2]
- 왼쪽 자식: a[i * 2 + 1 ]
- 오른쪽 자식: a[i * 2 + 2]
예를 들어 a[3]의 부모는 a[i]이고 왼쪽 자식과 오른쪽 자식은 각각 a[7], a[8]이다. 또 a[2]의 부모는 a[0]이고 왼쪽 자식과
오른쪽 자식은 각각 a[5]와 a[6]이다. 모두 위의 관계를 만족한다.

* 힙 정렬의 특징
힙 정렬은 '힙에서 최댓값은 루트에 위치한다'는 특징을 이용하여 정렬하는 알고리즘이다.
구체적으로 다음과 같은 작업을 반복한다.
- 힙에서 최댓값인 루트를 꺼낸다
- 루트 이외의 부분을 힙으로 만든다
이 과정에서 꺼낸 값을 나열하면 정렬이 끝난 배열이 완성된다. 즉, 힙 정렬은 선택 정렬을 응용한 알고리즘이다.
또한 힙 정렬에서 최댓값인 루트를 꺼낸 뒤 다시 남은 원소 중에서 최댓값을 구해야 한다.
예를 들어 힙으로 이루어진 원소 10개에서 최댓값을 꺼내면 남은 9개 원소에서 다시 최댓값을 구해야 한다.
따라서 남은 9개 원소로 구성한 트리도 힙이 되도록 재구성해야 한다.
(선택 정렬은 최솟값 또는 최댓값을 선택해 정렬하는 알고리즘이다)

* 루트를 삭제한 힙의 재구성
   a           루트를 삭제하고 마지막 원소를 루트로 이동한다
              10                        X                       1
            /   \                     /   \                   /   \
           9     5                   9     5                 9     5
          / \   / \         =>      / \   / \       =>      / \   / \
         8   3 2   4               8   3 2   4             8   3 2   4
        / \ /                     / \ /                   / \
       6  7 1                    6  7 1                  6  7
   a: 힙에서 루트인 10을 꺼낸다. 비어 있는 루트 위치에 힙의 마지막 원소인 1을 이동한다. 이때 이동한 <1 이외의> 원소는
      힙 상태를 유지한다. 따라서 1만 알맞은 위치로 이동하면 힙 상태를 유지할 수 있다.

   b         큰 값을 가진 자식과 위치를 교환한다
              1                         9                       9                     9
            /   \                     /   \                   /   \                 /   \
           9     5                   1     5                 8     5               8     5
          / \   / \         =>      / \   / \       =>      / \   / \       =>    / \   / \
         8   3 2   4               8   3 2   4             1   3 2   4           6   3 2   4
        / \                       / \                     / \                   / \
       6   7                     6   7                   6   7                 1   7
   b: 이제 1을 알맞은 위치로 이동시켜야 한다. 이동할 1의 자식은 9과 5이다. 힙을 구성하려면 1, 9, 5 가운데 최댓값이 가장
      위쪽에 위치해야 한다. '부모의 값 >= 자식의 값'이라는 힙의 조건이 성립하려면 두 자식을 비교하여 큰 값인 왼쪽 자식
      9와 교환한다. 그리고 1이 9의 위치로 내려온다. 이 작업을 반복한다.
이렇게 만든 트리는 힙 상태를 유지한다. 어떠한 부모와 자식 관계를 비교해도 '부모의 값 >= 자식의 값'이고, 최댓값인 9는 루트에
위치한다. 여기에서 1은 가장 아래쪽인 리프(leaf)의 위치까지 이동했다. 하지만 원소를 항상 끝까지 이동시킬 필요는 없다.
이동할 원소값보다 왼쪽과 오른쪽 두 자식이 작으면 더 이상 교환할 수 없으므로 그 시점에서 스캔을 종료한다. 따라서 루트를
삭제하고 다시 힙으로 만들기 위해 원소를 알맞은 위치로 이동하는 순서는 다음과 같다.

1. 루트를 꺼낸다
2. 마지막 원소(가장 하단의 오른쪽에 위치한 원소)를 루트로 이동한다.
3. 루트에서 시작하여 자신보다 값이 큰 자식과 자리를 바꾸고 아래쪽으로 내려가는 작업을 반복한다. 자식의 값이 작거나 리프의
   위치에 도달하면 종료한다.

* 힙 정렬 알고리즘 살펴보기
  n: 배열의 원소 수 / i: 배열의 마지막 인덱스              0  1 2 3 4 5 6 7 8 9(=i)
 1. i값을 n - 1로 초기화한다                           a[ 10 9 5 8 3 2 4 6 7 1 ]
 2. a[0]과 a[i]를 교환한다
 3. a[0], a[1], ..., a[i - 1]을 힙으로 만든다
 4. i값을 1씩 감소시켜 0이 되면 종료한다. 그렇지 않으면 2로 돌아간다
이 순서대로 힙 정렬을 수행한다. 이때 중요한 것은 배열의 처음 상태가 힙의 요구 사항을 만족하지 않을 수도 있다는 것이다.
따라서 이 순서를 적용하기 전에 배열을 반드시 힙으로 만들어야 한다.
루트를 삭제한 힙을 재구성하려면 마지막 원소를 루트로 이동시켜서 알맞은 위치까지 아래로 옮겨야 한다.
이 방법을 사용하면 가장 아랫부분의 작은 서브트리부터 상향식(bottom-up)으로 진행하여 전체배열을 힙으로 만들 수 있다.
먼저 가장 아랫부분의 오른쪽 서브트리의 힙을 만들고, 같은 단계에 있는 왼쪽 서브트리로 진행한다. 그 단계를 완료하면 한 단계
위로 이동하면서 각각의 서브트리를 힙으로 만든다.

* 힙 정렬의 시간복잡도
앞에서 힙 정렬은 선택 정렬을 응용한 알고리즘이라고 했다. 단순 선택 정렬은 아직 정렬하지 않은 부분의 모든 원소 중에서 최댓값을
선택한다. 힙 정렬은 맨 앞 원소를 꺼내는 것만으로 최댓값을 구할 수 있지만 남은 원소를 힙으로 재구성해야 한다.
단순 선택정렬에서 최댓값인 원소를 선택하는 시간복잡도는 O(n)이지만, 힙 정렬에서 다시 힙으로 만드는 작업의 시간복잡도는
O(log n)이다. [ 루트를 알맞은 위치까지 내리는 작업을 스캔할 때마다 선택 범위가 절반으로 줄어드는 이진 검색과 비슷하다 ]
따라서 단순 선택 정렬의 시간복잡도는 O(n^2)이지만, 힙 정렬은 원소의 개수만큼 작업을 반복하므로 전체 정렬하는데 걸리는 시간
복잡도는 O(n logn)으로 크게 줄어든다.
